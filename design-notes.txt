
# for debugging, call.MGRAST must be modular, have lots of parameters, or both.  modularity like this:

all components in braces are indicated as "required" parameters within the request description:

http://api.metagenomics.anl.gov/annotation/{name}/{TOKEN}  (status .. but misnamed in "required parameter" section)
http://api.metagenomics.anl.gov/annotation/{name}/{ID}  (many, e.g., metadata)
http://api.metagenomics.anl.gov/annotation/{name}/{id}  (m5nr)
http://api.metagenomics.anl.gov/annotation/{name}/{text}  (m5nr)

...but is request "name" consistently appended?  no: see "download" resource
			
type: synchronous (most) asynchronous (matrix), stream (annotation)

SERVER NAME, configurable with an assigned default

TEST NETWORK; SERVER AVAILABLE?
if (fail) server.path <- # replace with saved copy
set network available flag?

BUILD RESOURCE LIST from http://api.metagenomics.anl.gov/
	resources
		documentation
		url
		name

and ...

BUILD DOCS FOR EACH REQUEST from http://api.metagenomics.anl.gov/{resource}/
the essential things are, per resource:
	 [names of requests]
	 [format of requests]
	 [format of return value]

	requests
		request
		name
		description
		method (GET or POST)
		type
		parameters []
			body  [for POST]
			required  [path parameters]
			options  [query parameters]
		attributes  [i.e., expected contents of return value]
			x
			y
			z

"status" resource is undocumented and must be added manually


STORE VERSION OF API "DOCUMENTATION" OBJECTS INTERNALLY BUT ALSO REBUILD AT STARTUP


IDEA: add "flag" per resource and per request to indicate need for exceptional processing...
so, one standard method for conforming parts of the API with a standard "out" for handling exceptions
OR: mark nonstandard handling with "TWEAK" in comments

GENERAL REQUEST FORMAT
http://api.metagenomics.anl.gov/{resource}/{request}/{ID/text/required.param}?{optional.param=value}{...}

two functions may still be a good paradigm.
get - (mGet)
call - (call.MGRAST)
construct a call
issue & handle a call

function prototype: applies API exactly, with handling of communication issues and optional parsing:
--> returns data or file
--> http://server/resource/required.params?optional.params
--> "asynchronous" included in "..."

http://api.metagenomics.anl.gov/matrix/function
http://api.metagenomics.anl.gov/sequence/...
...





is.conforming <- function (resource, request, object, quiet=FALSE) {

### just to save typing:
api <- .MGRAST$api()
server <- .MGRAST$server()

# validation currently is only by presence/absence of top-level fields.
# more sophisticated validation would looke something like:
# errstr <- "not enough columns"
# warning(paste("non-conforming API resource received:",errstr))
# stop("fatally non-conforming API resource received")

check.content <- names(api[[resource]][[request]]$attributes) %in% names(object)
missing.content <- names(api[[resource]][[request]]$attributes) [!check.content]

# REFINE WITH A RECURSIVE CHECK FOR FIELDS WITHIN FIELDS
if (all (check.content)) return(TRUE)

# TWEAK: for approved exceptions, do not throw an error
subtype <- paste(resource, request, "/")
if (switch(subtype, 
	"matrix/function" = identical(missing.content,"generated_by"),
	"matrix/organism" = identical(missing.content,"date"),
	default=FALSE)) return(TRUE)

if (!quiet) warning("API resource of type ", subtype, " missing content: ", missing.content)
return(FALSE)
}

